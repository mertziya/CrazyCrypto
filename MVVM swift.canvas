{
	"nodes":[
		{"id":"c3fe1e90318e4722","type":"text","text":"```swift\n\nimport Foundation\n\nstruct Crypto : Codable { // the data for this struct will be dervied from a JSON DATA. so the data will be decoded from a JSON ata thats why this struct needs to be Decodable\n    \n    let currency : String\n    let price : String\n    \n}\n\n// Decodable: Sunucudan veriyi alıp değişkenlere tanımlamak için gerekli bir Protocol\n// Encodable: Verileri alıp sunucuya geri yollamak için gerekli olan bir Protocol\n// Codable: İki özelliği birden destekleyen bir Prtotocol\n\n```","x":2434,"y":-2068,"width":627,"height":633,"color":"6"},
		{"id":"9cfb5b4b8a460c74","type":"text","text":"# Project/Model/Crypto","x":2434,"y":-2156,"width":627,"height":88,"color":"5"},
		{"id":"1fb500bb1555fd18","type":"text","text":"```swift\n\n\nimport UIKit\nimport RxSwift\nimport RxCocoa\n\nclass CryptoViewController: UIViewController , UITableViewDelegate, UITableViewDataSource{\n    \n    var cryptoList = [Crypto]()\n    let cryptoVM = CryptoVM()\n    let disposeBag = DisposeBag()\n    \n    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {\n        return cryptoList.count\n    }\n    \n    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n        let cell = UITableViewCell()\n        var content = cell.defaultContentConfiguration()\n        content.text = cryptoList[indexPath.row].currency\n        content.secondaryText = cryptoList[indexPath.row].price\n        cell.contentConfiguration = content\n        return cell\n    }\n\n    \n    @IBOutlet weak var tableView: UITableView!\n    @IBOutlet weak var indicatorView: UIActivityIndicatorView!\n    \n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n\n        tableView.delegate = self\n        tableView.dataSource = self\n        \n        let urlString = \"https://raw.githubusercontent.com/atilsamancioglu/K21-JSONDataSet/refs/heads/master/crypto.json\"\n        \n        setupBindings() //\n        cryptoVM.requestData(urlString: urlString)\n        \n    }\n    \n    //MARK: - Binds the data to View so the data is shown to users properly\n    private func setupBindings(){ // we observe the CryptoVM data here and do the required operations like changeing the data on the screen.\n        \n        cryptoVM\n            .error\n            .observe(on: MainScheduler.asyncInstance)\n            .subscribe { errorString in\n                print(errorString)\n            }.disposed(by: disposeBag)\n        \n         cryptoVM\n             .cryptos\n             .observe(on: MainScheduler.asyncInstance)\n             .subscribe { cryptos in\n                 self.cryptoList = cryptos\n                 self.tableView.reloadData()\n             }\n             .disposed(by: disposeBag)\n         \n         cryptoVM\n            .loading\n            .bind(to: self.indicatorView.rx.isAnimating)\n            .disposed(by: disposeBag)\n        \n    }\n    \n}\n\n```\n","x":4160,"y":-1160,"width":1174,"height":1360,"color":"6"},
		{"id":"2f3e72583fd6bd94","type":"text","text":"# Project/View/CryptoViewController","x":4160,"y":-1236,"width":1174,"height":76,"color":"3"},
		{"id":"8311e730da84a97a","type":"text","text":"```swift\n\nimport Foundation\nimport RxSwift\nimport RxCocoa\n\n// Logic of RxSwift --> You **PUBLISH** the ViewModel and **SUBSCRIBE** from the view\n// --> in this case ve publish the CryptoVM and subscribe to CryptoVM from our ViewcController\n\nclass CryptoVM{\n    \n    let cryptos : PublishSubject<[Crypto]> = PublishSubject()\n    let error : PublishSubject<String> = PublishSubject()\n    let loading : PublishSubject<Bool> = PublishSubject()\n    \n    // These 3 objects are observables. We observe them from our View.\n    \n    func requestData(urlString : String){\n        self.loading.onNext(true)\n        \n        let url = URL(string: urlString)!\n        WebService().downloadCurrencies(url: url) { result in\n            self.loading.onNext(false)\n            switch result{\n            case .success(let cryptos): // inside the success([cryptos]) it returns a value and we assign that value to cryptos by let cryptos\n                self.cryptos.onNext(cryptos)\n                \n            case .failure(let error):\n                switch error{\n                case .parsingError:\n                    self.error.onNext(\"parsing error\")\n                case .serverError:\n                    self.error.onNext(\"server error\")\n                }\n                \n            }\n        }\n    }\n\n    \n}\n\n// In order to sent data from ViewModel --> View there are few methods that are being used:\n// 1 --> RxSwift\n// 2 --> Combine Framework\n// 3 --> Delegate Pattern\n\n```","x":2278,"y":640,"width":940,"height":1056,"color":"6"},
		{"id":"aff8e1d392f371c5","type":"text","text":"# Project/ViewModel/CryptoVM\n","x":2277,"y":560,"width":941,"height":80,"color":"4"},
		{"id":"95647df842eb298f","type":"text","text":"\n```swift\n\nimport Foundation\n\n\nenum CryptoError : Error {\n    case serverError\n    case parsingError\n}\n// this enum is defined in order to define the errortype used inside the WebService class's downloadCurrencies functions completion handler (closure)\n// the error can either be .serverError or .parsingError\n\n\nclass WebService {\n    \n    func downloadCurrencies(url : URL , completition: @escaping (Result<[Crypto] , CryptoError >) -> () ){\n        \n        URLSession.shared.dataTask(with: url) { data, respone, error in\n            if let error = error{\n                completition(.failure(.serverError))\n            }else if let data = data{\n                let cryptoList = try? JSONDecoder().decode([Crypto].self, from: data)\n                if let cryptoList = cryptoList {\n                    completition(.success(cryptoList)) // data decoded sucesfully\n                }else{\n                    completition(.failure(.parsingError)) // data decoded but couldn't parse\n                }\n            }\n        }.resume()\n        \n    }\n    \n}\n\n// if let error = error{ //codeblock } --> this is a method known as **OPTIONAL BINDING** and it ensures that optional value has a value.\n\n// @escaping --> means works after the function runs.\n\n// Result< 'success' , 'failiure' >  --> Closure tanımlarken kullanılır. Normalde return etmesini istediğimiz veri 'success'dür. Hata olması halinde return etmesini istedğimiz veri ise 'failiure'dur\n// Result'ın 'success' data type ını kendimiz belirleyebiliriz. Fakat 'failiure' kesinlikle Error data type olmalıdır.\n// Bu yüzdenyukarda tanımladığımız enum CryptoError, Error protocolunu adopt eder.\n\n// Bu örnek'te return etmesini istediğimiz değer Model klasörü içerisinde tanımladığımız Crypto Classınıun bir arrayidir o yüzden -> [Crypto]\n\n\n```","x":720,"y":-1060,"width":1020,"height":1160,"color":"6"},
		{"id":"a04a684b5dd62955","type":"text","text":"# Project/Service/WebService.swift","x":720,"y":-1100,"width":1020,"height":80,"color":"2"}
	],
	"edges":[
		{"id":"bfc21c6238b1ce18","fromNode":"95647df842eb298f","fromSide":"bottom","toNode":"8311e730da84a97a","toSide":"left","label":"the WebService function -> 'downloadCurrencies' is \nused inside the CryptoVM for assigning the returned values to the observable objects."},
		{"id":"9165c2e9a1be6ef5","fromNode":"8311e730da84a97a","fromSide":"right","toNode":"1fb500bb1555fd18","toSide":"left","label":"setupBinding() function is used to observe and change the UI \naccording to the observable objects that are coming from VM.\n\n\nthe given url is provided to the         cryptoVM.requestData(\"THEURL\") to get the required functionality.\n\n\n"},
		{"id":"a804597f0af85f54","fromNode":"c3fe1e90318e4722","fromSide":"right","toNode":"1fb500bb1555fd18","toSide":"left","label":"Crypto Model is used inside the CryptoViewController\nin order to set the data inside the the table view on a simple way"},
		{"id":"64a5835793c20a31","fromNode":"c3fe1e90318e4722","fromSide":"left","toNode":"a04a684b5dd62955","toSide":"top","label":"Provided Structure for the WebService.swift\n\nWebService().downloadCurrencies(..) returns \n[Crypto] on succesfull URLsession \n\n\n"}
	]
}